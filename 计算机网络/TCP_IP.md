## [UDP 和 TCP 的特点](#)
- ### [UDP](#)
  - 是无连接的，尽最大可能交付，没有拥塞控制，面向报文 （对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多
的交互通信。
- ### [TCP](#)
  - 是面向连接的，提供可靠交付，有流量控制，拥塞控 制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据
块），每一条 TCP 连接只能是点对点的（一对一）。
--- 
## [三次握手](#)
- ### [流程](#)
![](../img/tcp三次握手.png)

1. 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
2. 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
3. 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

### [为什么需要三次握手](#)
- 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
1. 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
2. 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
3. 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

- 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

---
## [四次挥手](#)
- ### [流程](#)
![](../img/tcp四次挥手.png)

1. 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
    - 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
2. 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
3. 服务器-关闭与客户端的连接，发送一个FIN给客户端
   - 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。
4. 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1
   - 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器
   - 设置的时间 2MSL。这么做有两个理由：
     - 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
     - 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

--- 

## [TCP可靠传输](#)
